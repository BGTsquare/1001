import React from 'react'
import { renderWithProviders, screen, waitFor } from '@/test/utils'
import { vi } from 'vitest'

// Mock auth provider so BookReader sees an authenticated user
vi.mock('@/contexts/auth-context', () => ({
  useAuth: () => ({ user: { id: 'test-user-id', reading_preferences: {} } })
}))

// Stub createObjectURL used for PDF blob URLs
;(global as any).URL.createObjectURL = vi.fn(() => 'blob:test')

import { BookReader } from '@/components/books/book-reader'

const TEST_BOOK = {
  id: 'test-book-id',
  title: 'Test Book',
  author: 'Author',
  content_url: 'book-content/test.pdf',
  is_free: true,
}

const TEST_LIBRARY = {
  id: 'lib-item',
  book_id: 'test-book-id',
  user_id: 'test-user-id',
  status: 'owned',
  progress: 0,
  last_read_position: null,
}

describe('BookReader (PDF path)', () => {
  beforeEach(() => vi.restoreAllMocks())

  it('renders PDF viewer or fallback download link when server returns pdf', async () => {
    const fetchMock = vi.fn()
    fetchMock.mockResolvedValueOnce({ ok: true, json: async () => ({ content: '<div>PDF Content</div>', contentFormat: 'pdf' }) })
    fetchMock.mockResolvedValueOnce({ ok: true, blob: async () => new Blob(['%PDF-1.4 test'], { type: 'application/pdf' }) })
    vi.stubGlobal('fetch', fetchMock)

    renderWithProviders(<BookReader book={TEST_BOOK as any} libraryItem={TEST_LIBRARY as any} />)

    await waitFor(() => expect(screen.queryByText(/Loading book content/i)).not.toBeInTheDocument())

    const downloadLink = screen.queryByText(/Download PDF/i)
    const pageLabel = screen.queryByText(/Page \d+ \//i)

    expect(downloadLink || pageLabel).toBeTruthy()
  })
})
